---
status: published
title: "Stepping Into ROM: Source-Level Debugging for Monitor Code"
summary: "When debugging user programs on the TEC-1, I kept hitting a wall at ROM boundaries. The debugger could step through my code, but the moment execution jumped into the monitor ROM, the source view went dark. I fixed that by teaching Debug80 to load external listings and build source maps from assembly files at session start."
tags:
  - debug80
  - tec1
  - z80
  - debugging
  - source-mapping
  - rom
series: debug80diaries
---

# Stepping Into ROM: Source-Level Debugging for Monitor Code

By John Hardy

When I step through a TEC-1 program, the interesting work often happens at the boundary. My code calls into the monitor ROM, and the ROM calls back. The trouble is that Debug80 only knew about the source files I assembled for the current session. The ROM was a black box. I could see it executing in the disassembly view, but I could not see the original source lines or set breakpoints by label. That gap made it hard to understand what the ROM was doing when my program misbehaved.

The fix required two changes. First, the debugger needed a way to load additional listing files that live outside the project. Second, it needed to build source maps from those listings so that stepping and breakpoints work the same way they do in user code. The result is a new `extraListings` configuration option that accepts a list of paths to `.lst` files. When a debug session starts, the adapter loads each listing, parses it, and merges the resulting segments into the main source map.

## The Extra Listings Configuration

The configuration lives in `debug80.json` alongside the other platform settings. A typical TEC-1 setup now looks like this:

```json
{
  "platform": "tec1",
  "tec1": {
    "romHex": "roms/tec1/mon-1b/mon-1b.hex",
    "extraListings": [
      "../debug80/roms/tec1/mon-1b/mon-1b.lst"
    ]
  }
}
```
@@Caption: TEC-1 configuration with an extra ROM listing.

The path is resolved relative to the `debug80.json` base directory. Absolute paths also work. If a listing file is missing, the adapter logs a warning to the Debug Console and continues without it. This keeps the session usable even when the ROM source is unavailable.

## Building Source Maps from Listings

A listing file contains the assembled output alongside the original source lines. The format varies by assembler, but the essential structure is an address column, a hex dump of the generated bytes, and the source text. The adapter parses each line and extracts address ranges for every instruction. Those ranges become segments in the source map.

The listing format from asm80 looks like this:

```
0000   C3 F0 05               JP   STARTMON
0003   FF                     DB   0xFF
...
05F0   31 D0 0F     STARTMON: LD   sp,0x0fd0
05F3   CD 31 01               CALL GETKEY
```
@@Caption: Excerpt from mon-1b.lst showing address, hex bytes, and source.

Each line with a valid address becomes a segment. The adapter records the start address, the byte count, and the line number. When the CPU hits an address in that range, the debugger can now jump to the correct line in the listing file.

## Compiling Source Files on the Fly

Listing files work well when they exist, but sometimes I only have the original assembly source. I wanted the debugger to handle that case too. If a listing file sits next to a `.source.asm` or `.asm` file with the same base name, the adapter compiles the source using asm80 and builds the mapping from the compiler output.

The compilation happens at session start. The adapter calls asm80 directly via its JavaScript API:

```typescript
asm80Module.fileGet((file: string, binary?: boolean) => {
  const resolved = path.resolve(baseDir, file);
  if (!fs.existsSync(resolved)) {
    return null;
  }
  return binary === true
    ? fs.readFileSync(resolved)
    : fs.readFileSync(resolved, 'utf-8');
});
const [err, compiled, symbols] = asm80Module.compile(sourceText, asm80Monolith.Z80);
```
@@Caption: Calling asm80 to compile a ROM source file.

The `fileGet` hook lets asm80 resolve include files relative to the source directory. The compile result contains a list of lines with addresses and byte counts, plus a symbol table. The adapter walks both structures and builds segments and anchors for the source map.

This approach means I can drop a ROM source file next to the listing and the debugger will pick it up automatically. I can set breakpoints by clicking in the source margin, and the stack trace will show the original labels instead of raw addresses.

## The ROM Source Picker

With multiple ROM sources loaded, I needed a way to open them during a session. The debugger now registers a command called `debug80.openRomSource`. It queries the adapter for the list of loaded ROM sources and presents them in a quick pick menu. Selecting an entry opens the file in the editor.

The command distinguishes between listing files and source files. If both exist for the same ROM, the picker shows both options. I can choose the listing when I want to see the hex dump, or the source when I want to read the assembly without the noise.

## Shadow Memory and Address Aliasing

The TEC-1G adds another layer of complexity. Its memory controller can shadow the ROM region at `0x0000–0x07FF` with RAM at `0xC000–0xC7FF`. When shadow mode is enabled, the CPU sees the high RAM contents at the low addresses. This is how the TEC-1G boots: the ROM lives at `0xC000`, but the CPU starts execution at `0x0000` because the shadow is active at power-on.

The debugger needed to understand this aliasing. When I set a breakpoint at a ROM label, the label resolves to an address like `0xC100`. But when shadow mode is on, the CPU executes that code at `0x0100`. The breakpoint would never fire because the addresses did not match.

I fixed this by teaching the breakpoint checker to consider shadow aliases. When the CPU stops, the adapter checks both the raw PC and its shadow alias against the breakpoint set. The same logic applies to source lookup. If the PC is in the shadowed region, the adapter tries the shadow alias when resolving the source file.

```typescript
private getShadowAlias(address: number): number | null {
  if (this.activePlatform !== 'tec1g') {
    return null;
  }
  const runtime = this.tec1gRuntime;
  if (!runtime || runtime.state.shadowEnabled !== true) {
    return null;
  }
  if (address < 0x0800) {
    return (0xc000 + address) & 0xffff;
  }
  return null;
}
```
@@Caption: Mapping low addresses to their shadow aliases.

This change also required updating the TEC-1G runtime to enable shadow mode at power-on. The previous behavior started with shadow disabled, which meant the ROM had to explicitly enable it before execution could begin. That was incorrect. The real hardware boots with shadow active so the CPU can fetch from ROM at address zero.

## What This Enables

I can now step through the TEC-1 monitor ROM the same way I step through my own code. When my program calls `GETKEY`, I can follow execution into the ROM and watch it scan the keypad. When a subroutine misbehaves, I can set a breakpoint inside the ROM and inspect the state when it fires.

The source map merging means that the debugger treats ROM code and user code as a unified address space. The stack trace shows labels from both. The disassembly view annotates ROM addresses with their source lines. The memory panel can jump to ROM symbols.

This is the debugging experience I wanted from the start. The ROM is no longer a black box. It is just another part of the program, visible and inspectable like everything else.
